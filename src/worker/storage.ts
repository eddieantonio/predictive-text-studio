import Dexie, { DexieOptions } from "dexie";
import { WordList } from "@common/types";
import { StoredWordList, StoredPackageInfo, keyboardDataObj } from "./models";
const DB_NAME = "dictionary_sources";
const SCHEMA_VERSION = 3;

/**
 * The key of the ONLY StoredPackageInfo record.
 */
const PACKAGE_ID = 0;

/**
 * A word list stored in the database.
 */
export interface StoredWordList {
  /** Autogenerated primary key */
  id?: number;

  /**
   * Typically the filename of the uploaded dictionary source.
   */
  name: string;
  /**
   * The actual contents of said file.
   */
  wordlist: WordList;
}

/**
 * The information needed to create a KMP file
 */
export interface StoredProjectData {
  /**
   * Primary key. For now, there is only one project, with PACKAGE_ID as its
   * primary key.
   */
  id?: number;

  /**
   * The name of language. Could be different than what is fetched by an API.
   */
  langName: string;

  /**
   * The valid BCP-47 tag for the language.
   */
  bcp47Tag: string;

  /**
   * Who created the model?
   */
  authorName: string;

  /**
   * A custom model ID string.
   */
  modelID?: string;

  /**
   * The model copyright.
   */
  copyright?: string;

  /**
   * The version number of the model.
   */
  version?: string;
}

export class PredictiveTextStudioDexie extends Dexie {
  files: Dexie.Table<StoredWordList, number>;
  projectData: Dexie.Table<StoredProjectData, number>;
export class PredictiveTextStudioDexie extends Dexie {
  files: Dexie.Table<StoredWordList, number>;
  packageInfo: Dexie.Table<StoredPackageInfo, number>;
  keyboardData: Dexie.Table<keyboardDataObj, number>;

  constructor(options?: DexieOptions) {
    super(DB_NAME, options);
    this.version(SCHEMA_VERSION).stores({
      /**
       * files Table Schema:
       *
       * +------------------+
       * | id (primary key) |
       * +------------------+
       * | name             |
       * +------------------+
       * | wordlist         |
       * +------------------+
       */
      files: "++id, name, wordlist",

      /**
       * projectData Table Schema:
       *
       * projectData stores optional and required metadata such as BCP-47,
       * language name, author name, copyright string, etc.
       *
       * +------------------+
       * | id (primary key) |
       * +------------------+
       * | langName         |
       * +------------------+
       * | bcp47Tag         |
       * +------------------+
       * | authorName       |
       * +------------------+
       * | modelID          |
       * +------------------+
       * | copyright        |
       * +------------------+
       * | version          |
       * +------------------+
       */
<<<<<<< HEAD
      projectData:
        "++id, langName, bcp47Tag, authorName, modelID, copyright, version",
=======
      packageInfo: "++id, bcp47Tag",
      /**
       * KMP keyboardData Table Scehma
       * +------------------------+
       * | bcp47Tag (primary key) |
       * +------------------------+
       * | language               |
       * +------------------------+
       */
      keyboardData: "bcp47Tag, langauge",
>>>>>>> implement featchning and storing kmp data
    });

    /* The assignments are not required by the runtime, however, they are
     * necessary for proper type-checking. */
    this.files = this.table("files");
<<<<<<< HEAD
    this.projectData = this.table("projectData");
=======
    this.packageInfo = this.table("packageInfo");
    this.keyboardData = this.table("keyboardData");
>>>>>>> implement featchning and storing kmp data
  }
}

/**
 * Single access point to store and retrieve persistent data in the
 * Predictive Text Studio application.
 */
export default class Storage {
  private db: PredictiveTextStudioDexie;

  constructor(db?: PredictiveTextStudioDexie) {
    this.db = db || new PredictiveTextStudioDexie();
  }

  /**
   * Saves a wordlist source file to storage.
   */
  saveFile(name: string, wordlist: WordList): Promise<void> {
    return this.db.transaction("readwrite", this.db.files, async () => {
      await this.db.files.where("name").equals(name).delete();
      await this.db.files.put({ name, wordlist });
    });
  }

  /**
   * Retrieves every file in the database as a list of {name, contents}
   * objects.
   */
  fetchAllFiles(): Promise<StoredWordList[]> {
    return this.db.files.toArray();
  }

  /**
   * Update BCP-47 tag to database
   */
  updateBCP47Tag(bcp47Tag: string): Promise<void> {
    return this.db.transaction("readwrite", this.db.projectData, async () => {
      const currentData = (await this.db.projectData.get({
        id: PACKAGE_ID,
      })) || { langName: "", bcp47Tag, authorName: "", id: PACKAGE_ID };
      currentData.bcp47Tag = bcp47Tag;
      await this.db.projectData.put(currentData);
    });
  }

  /**
   * Update required and some optional metadata to database
   */
  updateProjectData(metadata: { [key: string]: string }): Promise<void> {
    return this.db.transaction("readwrite", this.db.projectData, async () => {
      await this.db.projectData.put({
        langName: metadata.langName,
        bcp47Tag: metadata.bcp47Tag,
        authorName: metadata.authorName,
        modelID: metadata.modelID,
        copyright: metadata.copyright,
        version: metadata.version,
        id: PACKAGE_ID,
      });
    });
  }

  /**
   * Retrieves the current project data.
   */
  async fetchProjectData(): Promise<StoredProjectData> {
    const projectData = await this.db.projectData
      .where(":id")
      .equals(PACKAGE_ID)
      .first();

    if (projectData == undefined) {
      throw new Error("No project data has been stored");
    }

    return projectData;
  }
  /**
   * Save all keyboard info into the database
   */
  addKeybaordData(langauge: string, bcp47: string): Promise<void> {
    return this.db.transaction("readwrite", this.db.keyboardData, async () => {
      await this.db.keyboardData.put({ langauge, bcp47Tag: bcp47 });
    });
  }
  /**
   * Retrieves every keyboard data in the database as a list of {language, bcp47Tag}
   */
  fetchKeyboardData(): Promise<keyboardDataObj[]> {
    return this.db.keyboardData.toArray();
  }
}
